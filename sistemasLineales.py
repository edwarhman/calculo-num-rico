# -*- coding: utf-8 -*-
"""practica_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LM8BcELuugEalfqTYH28_5ZjBdbpV4iG
"""

import numpy as np


class SistemaLineal:
    def __init__(self, matriz_a, b):
        try:
            m, n = matriz_a.shape
            vector_size = b.size
        except Exception:
            raise ValueError("Input variables must be numpy arrays.")

        if m != n:
            raise ValueError("La matriz de coeficientes no es cuadrada.")

        if n != vector_size:
            raise ValueError(
                "El vector de términos independientes no es compatible con la matriz de coeficientes."
            )

        self.A = matriz_a
        self.b = b
        self.tamano = n

    def resolver_por_eliminacion_gaussiana(self):
        """
        Resuelve del sistema lineal mediante el método de eliminación gaussiana.
        """
        matrizSuperiorAumentada = self.obtener_matriz_triangular_superior_aumentada()
        return self.__resolver_por_sustitucion(
            matrizSuperiorAumentada, direction="haciaAtras"
        )

    def resolver_por_factorizacion_lu(self):
        """Obtiene la solución del sistema lineal mediante el método de factorización LU."""
        L, U = self.obtener_factorizacion__lu()
        matrizPrimeraSustitucion = self.__obtener_matriz_aumentada(L, self.b)
        y = self.__resolver_por_sustitucion(
            matrizPrimeraSustitucion, direction="haciaAdelante"
        )
        matrizSegundaSustitucion = self.__obtener_matriz_aumentada(U, y)
        return self.__resolver_por_sustitucion(
            matrizSegundaSustitucion, direction="haciaAtras"
        )

    def resolver_por_factorizacion_palu(self):
        """Obtiene la solución del sistema lineal mediante el método de factorización PALU."""
        P, _, L, U = self.obtener_factorizacion_palu()
        matrizPrimeraSustitucion = self.__obtener_matriz_aumentada(
            L, np.matmul(P, self.b)
        )
        y = self.__resolver_por_sustitucion(
            matrizPrimeraSustitucion, direction="haciaAdelante"
        )
        matrizSegunaSustitucion = self.__obtener_matriz_aumentada(U, y)
        return self.__resolver_por_sustitucion(
            matrizSegunaSustitucion, direction="haciaAtras"
        )

    def resolver_por_metodo_jacobi(self, vector_inicial, tolerancia=1e-10, iteraciones=100):
        """
        Obtiene la solución del sistema lineal mediante el método iterativo de Jacobi.

        Args:
            tolerancia (float): Tolerancia para la convergencia del método.
            iteraciones (int): Número de iteraciones del método.

        Returns:
            vector solución del sistema lineal (np.array).
        """
        expresionDeJacobi = self.__construir_expresion_jacobi()
        return self.__aplicar_metodo_iterativo(
            expresionDeJacobi,vector_inicial, iteraciones, tolerancia
        )

    def resolver_por_metodo_gauss_seidel(self, vector_inicial, iteraciones=100, tolerancia=1e-10):
        """
        Obtiene la solución del sistema lineal mediante el método
        de Gauss-Seidel.

        Args:
            iteraciones (int): Número de iteraciones del método.
            tolerancia (float): Tolerancia para la convergencia del método.

        Returns:
            vector solución del sistema lineal (np.array).
        """
        expresionDeGaussSeidel = self.__construir_expresion_gauss_seidel()
        return self.__aplicar_metodo_iterativo(
            expresionDeGaussSeidel, vector_inicial, iteraciones, tolerancia
        )

    def resolver_por_metodo_sor(self,vector_inicial, iteraciones=100, tolerancia=1e-10, w=0.5):
        """
        Obtiene la solución del sistema lineal mediante el método de SOR.

        Args:
            iteraciones (int): Número de iteraciones del método.
            tolerancia (float): Tolerancia para la convergencia del método.
            w (float): Peso del método.

        Returns:
            vector solución del sistema lineal (np.array).
        """

        expresionDeSOR = self.__construir_expresion_sor(w)
        return self.__aplicar_metodo_iterativo(expresionDeSOR,vector_inicial, iteraciones, tolerancia)

    def obtener_matriz_aumentada(self):
        """Obtiene la matriz aumentada que representa al sistema."""
        return self.__obtener_matriz_aumentada(self.A, self.b)

    def obtener_matriz_triangular_superior_aumentada(self):
        """Obtiene la matriz triangular superior aumentada que representa al sistema."""
        triangularSuperior = self.obtener_matriz_aumentada()
        for j in range(0, self.tamano - 1):
            k = self.__obtener_posicion_maximo_pivote_por_columna(
                triangularSuperior, j)
            triangularSuperior = self.__intercambiar_filas(
                triangularSuperior, j, k)
            for i in range(j + 1, self.tamano):
                # calculo de multiplicadores
                mu = triangularSuperior[i, j] / triangularSuperior[j, j]
                triangularSuperior[i, :] = triangularSuperior[i, :] - (
                    mu * triangularSuperior[j, :]
                )
        return triangularSuperior

    def obtener_factorizacion__lu(self):
        """Obtiene la factorizacion LU de la matriz de coeficientes A."""
        L = np.zeros((self.tamano, self.tamano))
        U = np.copy(self.A)

        for j in range(0, self.tamano - 1):
            for i in range(j + 1, self.tamano):
                if U[j, j] == 0:
                    raise ValueError("La matriz no posee factorizacion LU")
                mu = U[i, j] / U[j, j]  # calculo de multiplicadores
                U[i, :] = U[i, :] - (mu * U[j, :])  # aplicar operación en fila
                L[i, j] = mu  # asignacion de multiplicador

        L = np.identity(self.tamano) + L  # sumar matriz identidad
        return L, U

    def obtener_factorizacion_palu(self):
        """Obtiene la factorizacion PALU de la matriz de coeficientes A."""
        P = np.identity(self.tamano)
        L = np.zeros((self.tamano, self.tamano))
        U = np.copy(self.A)

        for j in range(0, self.tamano - 1):
            k = self.__obtener_posicion_maximo_pivote_por_columna(U, j)

            # Permutar matriz Superior
            U = self.__intercambiar_filas(U, j, k)
            # Registrar permutaciones
            P = self.__intercambiar_filas(P, j, k)
            # Permutar matriz inferior
            L = self.__intercambiar_filas(L, j, k)

            for i in range(j + 1, self.tamano):
                mu = U[i, j] / U[j, j]  # calculo de multiplicadores
                # multiplicacion por multiplicadores
                U[i, :] = U[i, :] - (mu * U[j, :])
                L[i, j] = mu  # registro de multiplicadores

        L = np.identity(self.tamano) + L  # sumar matriz identidad
        return P, self.A, L, U

    def obtener_factorizacion_dalau(self):
        """Obtiene la factorizacion D-Al-Au de la matriz de coeficientes A."""
        D = np.diagflat([self.A.diagonal()])
        Al = (np.tril(self.A) - D) * -1
        Au = (np.triu(self.A) - D) * -1
        return D, Al, Au

    def __construir_expresion_jacobi(self):
        D, Al, Au = self.obtener_factorizacion_dalau()
        if (
            self.__comprobar_convergencia(
                np.matmul(np.linalg.inv(D), (Al + Au)))
            == False
        ):
            raise ValueError("La matriz no converge a una solución")
        return lambda x: np.matmul(np.linalg.inv(D), np.matmul(Al + Au, x)) + np.matmul(
            np.linalg.inv(D), self.b
        )

    def __construir_expresion_gauss_seidel(self):
        D, Al, Au = self.obtener_factorizacion_dalau()
        if self.__comprobar_convergencia(np.matmul(np.linalg.inv(D - Al), Au)) == False:
            raise ValueError("La matriz no converge a una solución")
        return lambda x: np.matmul(np.linalg.inv(D - Al), np.matmul(Au, x)) + np.matmul(
            np.linalg.inv(D - Al), self.b
        )

    def __construir_expresion_sor(self, w):
        D, Al, Au = self.obtener_factorizacion_dalau()
        if (
            self.__comprobar_convergencia(
                np.matmul(np.linalg.inv(D - w * Al), w * Au + (1 - w) * D)
            )
            == False
        ):
            raise ValueError("La matriz no converge a una solución")
        return lambda x: np.matmul(
            np.linalg.inv(D - w * Al), np.matmul(w * Au + (1 - w) * D, x)
        ) + np.matmul(np.linalg.inv(D - w * Al), w * self.b)

    def __aplicar_metodo_iterativo(self, metodo, x, iteraciones, tolerancia):
        for _ in range(0, iteraciones):
            x_anterior = x
            x = metodo(x)
            if np.linalg.norm(x - x_anterior) <= tolerancia:
                break
        return x

    def __obtener_posicion_maximo_pivote_por_columna(self, matriz, columna):
        """Obtiene la posición del maximo pivote por columna."""
        posicion = np.argmax(np.abs(matriz[columna: self.tamano, columna]))
        return posicion + columna

    def __obtener_matriz_aumentada(self, matriz, columna):
        return np.copy(np.c_[matriz, columna])

    def __intercambiar_filas(self, matriz, posicion1, posicion2):
        copy = np.copy(matriz)
        aux = np.copy(matriz[posicion1, :])
        copy[posicion1, :] = np.copy(copy[posicion2, :])
        copy[posicion2, :] = np.copy(aux)
        return copy

    def __resolver_por_sustitucion(self, matriz, direction="haciaAtras"):
        x = np.zeros(self.tamano)
        rango = (
            range(0, self.tamano)
            if direction == "haciaAdelante"
            else range(self.tamano - 1, -1, -1)
        )
        for i in rango:
            x[i] = (
                matriz[i, self.tamano] - (np.sum(matriz[i, : self.tamano] * x))
            ) / matriz[i, i]
        return x

    def __obtener_radio_espectral(self, matriz):
        valores, vectores = np.linalg.eig(matriz)
        radioEspectral = np.max(np.abs(valores))
        return radioEspectral

    def __comprobar_convergencia(self, matriz):
        radioEspectral = self.__obtener_radio_espectral(matriz)
        return radioEspectral < 1

    def __es_diagonal_dominante(self, A, estricto=False):
        n = A.shape[1]

        for i in range(0, n):  # itera a través de cada fila
            # obtiene la suma absoluta de todos los elementos de la fila menos el elemento diagonal
            suma = np.sum(np.abs(A[i, :])) - np.abs(A[i, i])
            # si la suma es mayor a la diagonal absoluta, la matriz no es diagonal dominante
            if suma >= np.abs(A[i, i]) if estricto else suma > np.abs(A[i, i]):
                return False
        return True
