# -*- coding: utf-8 -*-
"""practica_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LM8BcELuugEalfqTYH28_5ZjBdbpV4iG
"""

import numpy as np

class NoSolutionError(Exception): ...
class SistemaLineal:
    def __init__(self, A, b):
        try:
            m, n = A.shape
            vector_size = b.size
        except:
            raise ValueError('Input variables must be numpy arrays.')

        if(m!=n):
            raise ValueError('La matriz de coeficientes no es cuadrada.')

        if(n!=vector_size):
            raise ValueError('El vector de términos independientes no es compatible con la matriz de coeficientes.')

        self.A = A
        self.b = b
        self.tamano = n
      
    def obtenerMatrizAumentada(self):
        return self.__sistemaLineal__obtenerMatrizAumentada(self.A, self.b)

    def obtenerMatrizTriangularSuperiorAumentada(self):
        triangularSuperior = np.copy(self.obtenerMatrizAumentada())
        for j in range(0, self.tamano-1): 
          k = np.argmax(np.abs(triangularSuperior[j:self.tamano,j])) # maximo pivote por columna
          k = k + j
          triangularSuperior = self.__sistemaLineal__intercambiarFilas(triangularSuperior, j, k)
          for i in range(j+1, self.tamano):
            mu = triangularSuperior[i,j]/triangularSuperior[j,j] # calculo de multiplicadores
            triangularSuperior[i,:] = triangularSuperior[i,:] - (mu*triangularSuperior[j,:])
        print(triangularSuperior)
        return triangularSuperior

    def resolverPorEliminacionGaussiana(self):
       matrizSuperiorAumentada = self.obtenerMatrizTriangularSuperiorAumentada()
       solucion = self.__sistemaLineal__resolverPorSustitucion(matrizSuperiorAumentada, direction='haciaAtras')
       return solucion

    def obtenerFactorizacionLU(self):
        L = np.zeros((self.tamano, self.tamano))
        U = np.copy(self.A)

        for j in range(0, self.tamano-1):
            k = np.argmax(np.abs(U[j:self.tamano,j])) # maximo pivote por columna
            k=k+j

            try:
                for i in range(j+1, self.tamano):
                    if (U[j,j] == 0):
                        raise ValueError('La matriz no posee factorizacion LU')
                    mu = U[i,j]/U[j,j] # calculo de multiplicadores
                    U[i,:] = U[i,:] - (mu*U[j,:])
                    L[i,j] = mu # asignacion de multiplicador
            except:
                raise ValueError('La matriz no posee factorizacion LU')

        L = np.identity(self.tamano) + L # sumar matriz identidad
        return L, U

    def obtenerFactorizacionPALU(self):
        P = np.identity(self.tamano)
        L = np.zeros((self.tamano, self.tamano))
        U = np.copy(self.A)

        for j in range(0, self.tamano-1):
            k = np.argmax(np.abs(U[j:self.tamano,j])) # maximo pivote por columna
            k=k+j

            # Permutar matriz Superior
            U = self.__sistemaLineal__intercambiarFilas(U, j, k)

            # Registrar permutaciones
            P = self.__sistemaLineal__intercambiarFilas(P, j, k)

            # Permutar matriz inferior
            L = self.__sistemaLineal__intercambiarFilas(L, j, k)

            for i in range(j+1, self.tamano):
                mu = U[i,j]/U[j,j] # calculo de multiplicadores
                U[i,:] = U[i,:] - (mu*U[j,:]) # multiplicacion por multiplicadores
                L[i,j] = mu # registro de multiplicadores

        L = np.identity(self.tamano) + L # sumar matriz identidad
        return P, self.A, L, U

    def obtenerFactorizacionDAlAu(self):
        D = np.diagflat([self.A.diagonal()])
        Al = (np.tril(self.A) - D ) * -1
        Au = (np.triu(self.A) - D) * -1
        return D, Al, Au

    def resolverPorFactorizacionLU(self):
        L, U = self.obtenerFactorizacionLU()
        y = self.__sistemaLineal__resolverPorSustitucion(
           self.__sistemaLineal__obtenerMatrizAumentada(L, self.b),
           direction='haciaAdelante'
        )
        return self.__sistemaLineal__resolverPorSustitucion(
            self.__sistemaLineal__obtenerMatrizAumentada(U, y),
            direction='haciaAtras'
        )

    def resolverPorFactorizacionPALU(self):
        P, A, L, U = self.obtenerFactorizacionPALU()
        y = self.__sistemaLineal__resolverPorSustitucion(
           self.__sistemaLineal__obtenerMatrizAumentada(L, np.matmul(P, self.b)),
           direction='haciaAdelante'
        )
        return self.__sistemaLineal__resolverPorSustitucion(
            self.__sistemaLineal__obtenerMatrizAumentada(U, y),
            direction='haciaAtras'
        )

    def resolverPorMetodoJacobi(self, tolerancia=1e-10, iteraciones=100):
        D = np.diagflat([self.A.diagonal()])
        Au = (np.triu(self.A) - D) * -1
        Al = (np.tril(self.A) - D ) * -1

        if(self.__sistemaLineal__comprobarConvergencia(np.matmul(np.linalg.inv(D), (Al + Au))) == False):
            raise ValueError('La matriz no converge a una solución')

        x = np.ones(self.tamano)
        # prev_x = np.zeros(self.tamano)

        # iteración del método de Jacobi
        for n in range(0, iteraciones):
            prev_x = x
            # encontrar x_k+1 mediante la ecuación de Jacobi
            x = np.matmul(np.linalg.inv(D), np.matmul(Al + Au, x)) + np.matmul(np.linalg.inv(D), self.b)

            if np.linalg.norm(x - prev_x) <= tolerancia:
                break

        return x
        

    def __sistemaLineal__esDiagonalDominante(self, A, estricto = False):
        n = A.shape[1]

        for i in range(0,n): # itera a través de cada fila
             # obtiene la suma absoluta de todos los elementos de la fila menos el elemento diagonal
            suma = np.sum(np.abs(A[i,:])) - np.abs(A[i,i])
            # si la suma es mayor a la diagonal absoluta, la matriz no es diagonal dominante
            if(suma >= np.abs(A[i,i]) if estricto else suma > np.abs(A[i,i])):
                return False
        return True


    def __sistemaLineal__obtenerMatrizAumentada(self, matriz, columna):
        return np.copy(np.c_[matriz, columna])

    def __sistemaLineal__intercambiarFilas(self,matriz, posicion1, posicion2):
      copy = np.copy(matriz)
      aux = np.copy(matriz[posicion1,:])
      copy[posicion1,:] = np.copy(copy[posicion2,:])
      copy[posicion2,:] = np.copy(aux)
      return copy
    
    def __sistemaLineal__resolverPorSustitucion(self, matriz, direction='haciaAtras'):
      x = np.zeros(self.tamano)
      rango = range(0, self.tamano) if direction == 'haciaAdelante' else range(self.tamano-1, -1, -1)
      for i in rango:
        x[i] = (matriz[i,self.tamano] - (np.sum(matriz[i,:self.tamano] * x))) / matriz[i, i]
      return x

    def __sistemaLineal__obtenerRadioEspectral(self, matriz):
      valores, vectores = np.linalg.eig(matriz)
      radioEspectral = np.max(np.abs(valores))
      return radioEspectral

    def __sistemaLineal__comprobarConvergencia(self, matriz):
      radioEspectral = self.__sistemaLineal__obtenerRadioEspectral(matriz)
      return radioEspectral < 1
        

"""# Métodos directos

## Cálculo de Triangular superior
"""

def triangsupMat(A, b):
  '''
  Ecuentra la matriz triangular superior de A y la transformación de b correspondiente

  Args:
    A (array): matriz
    b (array): vector

  Returns:
    B (array): matriz triangular superior
    c (array): vector
  '''
  (n,m) = A.shape
  o = b.size
  B = []

  if (m!=n):
    print('La matriz no es cuadrada')
    return
  if(n!=o):
    print('El sistema no es compatible determinado')
    return

  B = np.copy(A)
  c = np.copy(b)

  # pivoteo parcial
  for j in range(0,n-1):
    k = np.argmax(np.abs(B[j:n,j])) # maximo pivote por columna
    k=k+j
    # intercambio de filas
    faux = np.copy(B[j,:])
    B[j,:] = np.copy(B[k,:])
    B[k,:] = np.copy(faux)
    # intercambio elementos del vector
    caux = c[j]
    c[j] = c[k]
    c[k] = caux
    for i in range(j+1,n):
      mu = B[i,j]/B[j,j] # calculo de multiplicadores
      B[i,:] = B[i,:] - (mu*B[j,:])
      c[i] = c[i] - (mu*c[j])
  return B, c

def resolverPorSustitucion(A, b, forward=False):
  """Resuelve un sistema de ecuaciones lineales mediante la sustitucion
  de variables.

  Args:
    A (np.array): Matriz de ecuaciones.
    b (np.array): Vector de constantes.
    forward (bool): Direccion de la resolucion. True: hacia arriba, False: hacia abajo.

  Returns:
    np.array: Vector de solucion.
  """

  n = b.size
  x = np.zeros(n)
  rango = range(0, n) if forward else range(n-1, -1, -1)

  for i in rango:
    x[i] = (b[i] - (np.sum(A[i,:] * x))) / A[i, i]

  return x


def resolverSistemaEliminacionGaussiana(A, b):
    '''
    Resuelve el sistema de ecuaciones AX = B mediante el método de Gauss-Jordan

    Args:
    A (array): matriz de ecuaciones
    b (array): vector de constantes

    Returns:
    array: vector de solución
    '''
    B, c = triangsupMat(A,b)
    return resolverPorSustitucion(B, c)

def factolizarLU(A):
    '''
    Factorizacion LU de una matriz

    Args:
        A (array): matriz a factorizar
    Returns:
        L (array): matriz L de la factorizacion LU
        U (array): matriz U de la factorizacion LU
    '''
    (n,m) = A.shape

    if (m!=n):
        print ('La matriz no es cuadrada')
        return

    # inicializacion de matrizes
    U = []
    L = np.zeros((n,n))

    U = np.copy(A)
    for j in range(0,n-1):
        k = np.argmax(np.abs(U[j:n,j])) # maximo pivote por columna
        k=k+j

        for i in range(j+1,n):
             mu = U[i,j]/U[j,j]    # calculo de multiplicadores
             U[i,:] = U[i,:] - (mu*U[j,:]) # multiplicacion por el multiplicador
             L[i,j] = mu # asignacion de multiplicador

    L = np.identity(n) + L # sumar matriz identidad
    return L, U

def resolverSistemaLU(A, b):
  '''
  Resuelve un sistema de ecuaciones lineales usando el metodo LU

  Args:
    A (array): matriz de la ecuacion
    b (array): vector de la ecuacion

  Returns:
    array: vector de la solucion
  '''
  L, U = factolizarLU(A)
  y = resolverPorSustitucion(L,b, forward=True)
  return resolverPorSustitucion(U, y)

def factolizarPALU(A):
    '''
    Factorizacion de matrizes cuadradas por LU y permutaciones de filas

    Args:
        A (array): matriz a factorizar
    Returns:
        P (array): matriz de permutaciones
        L (array): matriz L
        U (array): matriz U
    '''
    (n,m) = A.shape


    if (m!=n):
        print ('La matriz no es cuadrada')
        return

    U = []
    P = np.identity(n)
    L = np.zeros((n,n))

    U = np.copy(A)
    for j in range(0,n-1):
        k = np.argmax(np.abs(U[j:n,j])) # maximo pivote por columna
        k=k+j

        # Permutar matriz Superior
        faux = np.copy(U[j,:])
        U[j,:] = np.copy(U[k,:])
        U[k,:] = np.copy(faux)

        # Registrar permutaciones
        paux = np.copy(P[j,:])
        P[j,:] = np.copy(P[k,:])
        P[k,:] = np.copy(paux)

        # Permutar matriz inferior
        laux = np.copy(L[j,:])
        L[j,:] = np.copy(L[k,:])
        L[k,:] = np.copy(laux)


        for i in range(j+1,n):
             mu = U[i,j]/U[j,j]    # calculo de multiplicadores
             U[i,:] = U[i,:] - (mu*U[j,:]) # multiplicacion por multiplicadores
             L[i,j] = mu # registro de multiplicadores

    L = np.identity(n) + L # sumar matriz identidad
    return P, L, U

def resolverSistemaPALU(A, b):
  '''
  Resuelve un sistema de ecuaciones lineales mediante el método de PALU

  Args:
    A (array): matriz de ecuaciones
    b (array): vector de constantes

  Returns:
    array: vector de solución
  '''
  P, L, U = factolizarPALU(A)
  y = resolverPorSustitucion(L,np.matmul(P,b), forward=True)
  return resolverPorSustitucion(U, y)
  # return np.round(resolverPorSustitucion(U, y))

"""# Métodos iterativos
"""

def comprobarMatrizDiagonalDominante(A, estricto = False):
    '''
    Devuelve True si la matriz es diagonal dominante, False en caso contrario

    '''
    n = A.shape[1]

    for i in range(0,n): # itera a través de cada fila
         # obtiene la suma absoluta de todos los elementos de la fila menos el elemento diagonal
        suma = np.sum(np.abs(A[i,:])) - np.abs(A[i,i])
        # si la suma es mayor a la diagonal absoluta, la matriz no es diagonal dominante
        if(suma >= np.abs(A[i,i]) if estricto else suma > np.abs(A[i,i])):
            return False
    return True

def comprobarConvergenciaSolucion(A):
    """## Comprobar Convergencia
    Mediante el uso del radio espectral de una matriz, determina si un sistema de
    ecuaciones lineales converge a una solución o no.
    """
    valores, vectores = np.linalg.eig(A) # determina los valores propios de la matriz
    radioEspectral = np.max(np.abs(valores)) # determina el radio espectral de la matriz
    print('Radio espectral: ', radioEspectral, 'converge:', radioEspectral <= 1)
    return radioEspectral < 1


def resolverJacobi(A, b, iteraciones):
    '''
    Resuelve la matriz A de orden n x n mediante el método de Jacobi.

    Args:
        A (np.array): matriz de orden n x n
        b (np.array): vector de orden n
        iteraciones (int): número de iteraciones

    Returns:
        np.array: solución de la matriz A
    '''
    m, n = A.shape

    if(m!=n):
        print('La matriz no es cuadrada')
        return

    # esEstrictamenteDiagonalDominante = comprobarMatrizDiagonalDominante(A, estricto=True)
    # print(' es edd', esEstrictamenteDiagonalDominante)
    # if(esEstrictamenteDiagonalDominante == False):
    #     print('La matriz no es estrictamente diagonal dominante')
    #     return

    # construcción de parametros para aplicar el metodo de Jacobi
    D = np.diagflat([A.diagonal()])
    Au = (np.triu(A) - D) * -1
    Al = (np.tril(A) - D ) * -1

    if(comprobarConvergenciaSolucion(np.matmul(np.linalg.inv(D), (Al + Au))) == False):
        print('La matriz no converge a una solución')
        return

    x = np.ones(n)

    # iteración del método de Jacobi
    for n in range(0, iteraciones):
        # encontrar x_k+1 mediante la ecuación de Jacobi
        x = np.matmul(np.linalg.inv(D), np.matmul(Al + Au, x)) + np.matmul(np.linalg.inv(D), b)

    return x

def resolverGaussSeidel(A, b, iteraciones):
    '''
    Resuelve un sistema de ecuaciones lineales mediante el método de Gauss-Seidel.

    Args:
        A (np.array): Matriz de la ecuación a resolver.
        b (np.array): Vector de los constantes de la ecuación.
        iteraciones (int): Número de iteraciones del método.

    Returns:
        np.array: Vector de solución de la ecuación.
    '''

    m, n = A.shape

    if(m!=n):
        print('La matriz no es cuadrada')
        return

    # if(comprobarMatrizDiagonalDominante(A, estricto=True) == False):
    #     print('La matriz no es estrictamente diagonal dominante')
    #     return

    D = np.diagflat([A.diagonal()])
    Au = (np.triu(A) - D) * -1
    Al = (np.tril(A) - D ) * -1

    if(comprobarConvergenciaSolucion(np.matmul(np.linalg.inv(D - Al), Au)) == False):
        print('La matriz no converge a una solución')
        return

    x = np.ones(n)


    for n in range(0, iteraciones):
        # encontrar solución x_k+1 usando la ecuación de Gauss-Seidel
        x = np.matmul(np.linalg.inv(D - Al), np.matmul(Au, x)) + np.matmul(np.linalg.inv(D - Al), b)

    return x


def resolverSOR(A, b, iteraciones, w):
    '''
    Resuelve el sistema de ecuaciones AX = B usando el método de SOR.

    Args:
        A (array): matriz de la ecuación AX = B
        b (array): vector de la ecuación AX = B
        iteraciones (int): número de iteraciones
        w (float): peso de la matriz diagonal dominante

    Returns:
        array: vector de la solución de la ecuación AX = B
    '''
    m, n = A.shape

    if(m!=n):
        print('La matriz no es cuadrada')
        return

    # if(comprobarMatrizDiagonalDominante(A, estricto=True) == False):
    #     print('La matriz no es estrictamente diagonal dominante')
    #     return

    # construir los parametros para aplicar el algoritmo de SOR
    D = np.diagflat([A.diagonal()])
    Au = (np.triu(A) - D) * -1
    Al = (np.tril(A) - D ) * -1

    # if(comprobarConvergenciaSolucion(np.matmul(np.linalg.inv(D - w*Al), w*Au + (1-w)*D)) == False):
    #     print('La matriz no converge a una solución')
    #     return

    x = np.ones(n)

    for n in range(0, iteraciones):
        # calcular la solución x_k+1 de la ecuación AX = B usando el algoritmo de SOR
        x = np.matmul(np.linalg.inv(D - w*Al), np.matmul(w*Au + (1-w)*D, x)) + np.matmul(np.linalg.inv(D - w*Al), w*b)

    return x
