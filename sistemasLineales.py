# -*- coding: utf-8 -*-
"""practica_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LM8BcELuugEalfqTYH28_5ZjBdbpV4iG
"""

import numpy as np

class NoSolutionError(Exception): ...
class SistemaLineal:
    def __init__(self, A, b):
        try:
            m, n = A.shape
            vector_size = b.size
        except:
            raise ValueError('Input variables must be numpy arrays.')

        if(m!=n):
            raise ValueError('La matriz de coeficientes no es cuadrada.')

        if(n!=vector_size):
            raise ValueError('El vector de términos independientes no es compatible con la matriz de coeficientes.')

        self.A = A
        self.b = b
        self.tamano = n
      
    def obtenerMatrizAumentada(self):
        '''Obtiene la matriz aumentada que representa al sistema.'''
        return self.__sistemaLineal__obtenerMatrizAumentada(self.A, self.b)

    def obtenerMatrizTriangularSuperiorAumentada(self):
        '''Obtiene la matriz triangular superior aumentada que representa al sistema.'''
        triangularSuperior = np.copy(self.obtenerMatrizAumentada())
        for j in range(0, self.tamano-1): 
          k = np.argmax(np.abs(triangularSuperior[j:self.tamano,j])) # maximo pivote por columna
          k = k + j
          triangularSuperior = self.__sistemaLineal__intercambiarFilas(triangularSuperior, j, k)
          for i in range(j+1, self.tamano):
            mu = triangularSuperior[i,j]/triangularSuperior[j,j] # calculo de multiplicadores
            triangularSuperior[i,:] = triangularSuperior[i,:] - (mu*triangularSuperior[j,:])
        print(triangularSuperior)
        return triangularSuperior

    def resolverPorEliminacionGaussiana(self):
        '''Obtiene la resolución del sistema lineal mediante el método de eliminación gaussiana.'''
        matrizSuperiorAumentada = self.obtenerMatrizTriangularSuperiorAumentada()
        solucion = self.__sistemaLineal__resolverPorSustitucion(matrizSuperiorAumentada, direction='haciaAtras')
        return solucion

    def obtenerFactorizacionLU(self):
        '''Obtiene la factorizacion LU de la matriz de coeficientes A.'''
        L = np.zeros((self.tamano, self.tamano))
        U = np.copy(self.A)

        for j in range(0, self.tamano-1):
            k = np.argmax(np.abs(U[j:self.tamano,j])) # maximo pivote por columna
            k=k+j

            try:
                for i in range(j+1, self.tamano):
                    if (U[j,j] == 0):
                        raise ValueError('La matriz no posee factorizacion LU')
                    mu = U[i,j]/U[j,j] # calculo de multiplicadores
                    U[i,:] = U[i,:] - (mu*U[j,:])
                    L[i,j] = mu # asignacion de multiplicador
            except:
                raise ValueError('La matriz no posee factorizacion LU')

        L = np.identity(self.tamano) + L # sumar matriz identidad
        return L, U

    def obtenerFactorizacionPALU(self):
        '''Obtiene la factorizacion PALU de la matriz de coeficientes A.'''
        P = np.identity(self.tamano)
        L = np.zeros((self.tamano, self.tamano))
        U = np.copy(self.A)

        for j in range(0, self.tamano-1):
            k = np.argmax(np.abs(U[j:self.tamano,j])) # maximo pivote por columna
            k=k+j

            # Permutar matriz Superior
            U = self.__sistemaLineal__intercambiarFilas(U, j, k)

            # Registrar permutaciones
            P = self.__sistemaLineal__intercambiarFilas(P, j, k)

            # Permutar matriz inferior
            L = self.__sistemaLineal__intercambiarFilas(L, j, k)

            for i in range(j+1, self.tamano):
                mu = U[i,j]/U[j,j] # calculo de multiplicadores
                U[i,:] = U[i,:] - (mu*U[j,:]) # multiplicacion por multiplicadores
                L[i,j] = mu # registro de multiplicadores

        L = np.identity(self.tamano) + L # sumar matriz identidad
        return P, self.A, L, U

    def obtenerFactorizacionDAlAu(self):
        '''Obtiene la factorizacion D-Al-Au de la matriz de coeficientes A.'''
        D = np.diagflat([self.A.diagonal()])
        Al = (np.tril(self.A) - D ) * -1
        Au = (np.triu(self.A) - D) * -1
        return D, Al, Au

    def resolverPorFactorizacionLU(self):
        '''Obtiene la solución del sistema lineal mediante el método de factorización LU.'''
        L, U = self.obtenerFactorizacionLU()
        y = self.__sistemaLineal__resolverPorSustitucion(
           self.__sistemaLineal__obtenerMatrizAumentada(L, self.b),
           direction='haciaAdelante'
        )
        return self.__sistemaLineal__resolverPorSustitucion(
            self.__sistemaLineal__obtenerMatrizAumentada(U, y),
            direction='haciaAtras'
        )

    def resolverPorFactorizacionPALU(self):
        '''Obtiene la solución del sistema lineal mediante el método de factorización PALU.'''
        P, A, L, U = self.obtenerFactorizacionPALU()
        y = self.__sistemaLineal__resolverPorSustitucion(
           self.__sistemaLineal__obtenerMatrizAumentada(L, np.matmul(P, self.b)),
           direction='haciaAdelante'
        )
        return self.__sistemaLineal__resolverPorSustitucion(
            self.__sistemaLineal__obtenerMatrizAumentada(U, y),
            direction='haciaAtras'
        )

    def resolverPorMetodoJacobi(self, tolerancia=1e-10, iteraciones=100):
        '''
        Obtiene la solución del sistema lineal mediante el método iterativo de Jacobi.
        
        Args:
            tolerancia (float): Tolerancia para la convergencia del método.
            iteraciones (int): Número de iteraciones del método.

        Returns:
            vector solución del sistema lineal (np.array).
        '''
        expresionDeJacobi = self.__sistemaLineal__construirExpresionDeJacobi()
        return self.__sistemaLineal__aplicarMetodoIterativo(expresionDeJacobi, iteraciones, tolerancia)

    def resolverPorMetodoGaussSeidel(self, iteraciones, tolerancia=1e-10):
        '''
        Obtiene la solución del sistema lineal mediante el método de Gauss-Seidel.
        
        Args:
            iteraciones (int): Número de iteraciones del método.
            tolerancia (float): Tolerancia para la convergencia del método.

        Returns:
            vector solución del sistema lineal (np.array).
        '''
        expresionDeGaussSeidel = self.__sistemaLineal__construirExpresionDeGaussSeidel()
        return self.__sistemaLineal__aplicarMetodoIterativo(expresionDeGaussSeidel, iteraciones, tolerancia)

    def resolverPorMetodoSOR(self, iteraciones, tolerancia=1e-10, w=0.5):
        '''
        Obtiene la solución del sistema lineal mediante el método de SOR.
        
        Args:
            iteraciones (int): Número de iteraciones del método.
            tolerancia (float): Tolerancia para la convergencia del método.
            w (float): Peso del método.

        Returns:
            vector solución del sistema lineal (np.array).
        '''
        expresionDeSOR = self.__sistemaLineal__construirExpresionDeSOR(w)
        return self.__sistemaLineal__aplicarMetodoIterativo(expresionDeSOR, iteraciones, tolerancia)

    def __sistemaLineal__construirExpresionDeJacobi(self):
        D, Al, Au = self.obtenerFactorizacionDAlAu()
        if(self.__sistemaLineal__comprobarConvergencia(np.matmul(np.linalg.inv(D), (Al + Au))) == False):
            raise ValueError('La matriz no converge a una solución')
        return lambda x: np.matmul(np.linalg.inv(D), np.matmul(Al + Au, x)) + np.matmul(np.linalg.inv(D), self.b)

    def __sistemaLineal__construirExpresionDeGaussSeidel(self):
        D, Al, Au = self.obtenerFactorizacionDAlAu()
        if(self.__sistemaLineal__comprobarConvergencia(np.matmul(np.linalg.inv(D - Al), Au)) == False):
            raise ValueError('La matriz no converge a una solución')
        return lambda x: np.matmul(np.linalg.inv(D - Al), np.matmul(Au, x)) + np.matmul(np.linalg.inv(D - Al), self.b)

    def __sistemaLineal__construirExpresionDeSOR(self, w):
        D, Al, Au = self.obtenerFactorizacionDAlAu()
        if(self.__sistemaLineal__comprobarConvergencia(np.matmul(np.linalg.inv(D - w*Al), w*Au + (1-w)*D)) == False):
            raise ValueError('La matriz no converge a una solución')
        return lambda x: np.matmul(np.linalg.inv(D - w*Al), np.matmul(w*Au + (1-w)*D, x)) + np.matmul(np.linalg.inv(D - w*Al), w*self.b)

    def __sistemaLineal__aplicarMetodoIterativo(self, metodo, iteraciones, tolerancia):
        x = np.ones(self.tamano)
        for _ in range(0, iteraciones):
            x_anterior = x
            x = metodo(x)
            if np.linalg.norm(x - x_anterior) <= tolerancia:
                break
        return x

    def __sistemaLineal__esDiagonalDominante(self, A, estricto = False):
        n = A.shape[1]

        for i in range(0,n): # itera a través de cada fila
             # obtiene la suma absoluta de todos los elementos de la fila menos el elemento diagonal
            suma = np.sum(np.abs(A[i,:])) - np.abs(A[i,i])
            # si la suma es mayor a la diagonal absoluta, la matriz no es diagonal dominante
            if(suma >= np.abs(A[i,i]) if estricto else suma > np.abs(A[i,i])):
                return False
        return True


    def __sistemaLineal__obtenerMatrizAumentada(self, matriz, columna):
        return np.copy(np.c_[matriz, columna])

    def __sistemaLineal__intercambiarFilas(self,matriz, posicion1, posicion2):
      copy = np.copy(matriz)
      aux = np.copy(matriz[posicion1,:])
      copy[posicion1,:] = np.copy(copy[posicion2,:])
      copy[posicion2,:] = np.copy(aux)
      return copy
    
    def __sistemaLineal__resolverPorSustitucion(self, matriz, direction='haciaAtras'):
      x = np.zeros(self.tamano)
      rango = range(0, self.tamano) if direction == 'haciaAdelante' else range(self.tamano-1, -1, -1)
      for i in rango:
        x[i] = (matriz[i,self.tamano] - (np.sum(matriz[i,:self.tamano] * x))) / matriz[i, i]
      return x

    def __sistemaLineal__obtenerRadioEspectral(self, matriz):
      valores, vectores = np.linalg.eig(matriz)
      radioEspectral = np.max(np.abs(valores))
      return radioEspectral

    def __sistemaLineal__comprobarConvergencia(self, matriz):
      radioEspectral = self.__sistemaLineal__obtenerRadioEspectral(matriz)
      return radioEspectral < 1
 