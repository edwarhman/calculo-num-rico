# -*- coding: utf-8 -*-
"""practica_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LM8BcELuugEalfqTYH28_5ZjBdbpV4iG
"""

import numpy as np

"""# Métodos directos

## Cálculo de Triangular superior
"""

def triangsupMat(A, b):
  '''
  Ecuentra la matriz triangular superior de A y la transformación de b correspondiente

  Args:
    A (array): matriz
    b (array): vector

  Returns:
    B (array): matriz triangular superior
    c (array): vector
  '''
  (n,m) = A.shape
  o = b.size
  B = []

  if (m!=n):
    print('La matriz no es cuadrada')
    return
  if(n!=o):
    print('El sistema no es compatible determinado')
    return

  B = np.copy(A)
  c = np.copy(b)

  # pivoteo parcial
  for j in range(0,n-1):
    k = np.argmax(np.abs(B[j:n,j])) # maximo pivote por columna
    k=k+j
    # intercambio de filas
    faux = np.copy(B[j,:])
    B[j,:] = np.copy(B[k,:])
    B[k,:] = np.copy(faux)
    # intercambio elementos del vector
    caux = c[j]
    c[j] = c[k]
    c[k] = caux
    for i in range(j+1,n):
      mu = B[i,j]/B[j,j] # calculo de multiplicadores
      B[i,:] = B[i,:] - (mu*B[j,:])
      c[i] = c[i] - (mu*c[j])
  return B, c

def resolverPorSustitucion(A, b, forward=False):
  """Resuelve un sistema de ecuaciones lineales mediante la sustitucion
  de variables.

  Args:
    A (np.array): Matriz de ecuaciones.
    b (np.array): Vector de constantes.
    forward (bool): Direccion de la resolucion. True: hacia arriba, False: hacia abajo.

  Returns:
    np.array: Vector de solucion.
  """

  n = b.size
  x = np.zeros(n)
  rango = range(0, n) if forward else range(n-1, -1, -1)

  for i in rango:
    x[i] = (b[i] - (np.sum(A[i,:] * x))) / A[i, i]

  return x


def resolverSistemaEliminacionGaussiana(A, b):
    '''
    Resuelve el sistema de ecuaciones AX = B mediante el método de Gauss-Jordan

    Args:
    A (array): matriz de ecuaciones
    b (array): vector de constantes

    Returns:
    array: vector de solución
    '''
    B, c = triangsupMat(A,b)
    return resolverPorSustitucion(B, c)

def factolizarLU(A):
    '''
    Factorizacion LU de una matriz

    Args:
        A (array): matriz a factorizar
    Returns:
        L (array): matriz L de la factorizacion LU
        U (array): matriz U de la factorizacion LU
    '''
    (n,m) = A.shape

    if (m!=n):
        print ('La matriz no es cuadrada')
        return

    # inicializacion de matrizes
    U = []
    L = np.zeros((n,n))

    U = np.copy(A)
    for j in range(0,n-1):
        k = np.argmax(np.abs(U[j:n,j])) # maximo pivote por columna
        k=k+j

        for i in range(j+1,n):
             mu = U[i,j]/U[j,j]    # calculo de multiplicadores
             U[i,:] = U[i,:] - (mu*U[j,:]) # multiplicacion por el multiplicador
             L[i,j] = mu # asignacion de multiplicador

    L = np.identity(n) + L # sumar matriz identidad
    return L, U

def resolverSistemaLU(A, b):
  '''
  Resuelve un sistema de ecuaciones lineales usando el metodo LU

  Args:
    A (array): matriz de la ecuacion
    b (array): vector de la ecuacion

  Returns:
    array: vector de la solucion
  '''
  L, U = factolizarLU(A)
  y = resolverPorSustitucion(L,b, forward=True)
  return resolverPorSustitucion(U, y)

def factolizarPALU(A):
    '''
    Factorizacion de matrizes cuadradas por LU y permutaciones de filas

    Args:
        A (array): matriz a factorizar
    Returns:
        P (array): matriz de permutaciones
        L (array): matriz L
        U (array): matriz U
    '''
    (n,m) = A.shape


    if (m!=n):
        print ('La matriz no es cuadrada')
        return

    U = []
    P = np.identity(n)
    L = np.zeros((n,n))

    U = np.copy(A)
    for j in range(0,n-1):
        k = np.argmax(np.abs(U[j:n,j])) # maximo pivote por columna
        k=k+j

        # Permutar matriz Superior
        faux = np.copy(U[j,:])
        U[j,:] = np.copy(U[k,:])
        U[k,:] = np.copy(faux)

        # Registrar permutaciones
        paux = np.copy(P[j,:])
        P[j,:] = np.copy(P[k,:])
        P[k,:] = np.copy(paux)

        # Permutar matriz inferior
        laux = np.copy(L[j,:])
        L[j,:] = np.copy(L[k,:])
        L[k,:] = np.copy(laux)


        for i in range(j+1,n):
             mu = U[i,j]/U[j,j]    # calculo de multiplicadores
             U[i,:] = U[i,:] - (mu*U[j,:]) # multiplicacion por multiplicadores
             L[i,j] = mu # registro de multiplicadores

    L = np.identity(n) + L # sumar matriz identidad
    return P, L, U

def resolverSistemaPALU(A, b):
  '''
  Resuelve un sistema de ecuaciones lineales mediante el método de PALU

  Args:
    A (array): matriz de ecuaciones
    b (array): vector de constantes

  Returns:
    array: vector de solución
  '''
  P, L, U = factolizarPALU(A)
  y = resolverPorSustitucion(L,np.matmul(P,b), forward=True)
  return resolverPorSustitucion(U, y)
  # return np.round(resolverPorSustitucion(U, y))

"""# Métodos iterativos
"""

def comprobarMatrizDiagonalDominante(A, estricto = False):
    '''
    Devuelve True si la matriz es diagonal dominante, False en caso contrario

    '''
    n = A.shape[1]

    for i in range(0,n): # itera a través de cada fila
         # obtiene la suma absoluta de todos los elementos de la fila menos el elemento diagonal
        suma = np.sum(np.abs(A[i,:])) - np.abs(A[i,i])
        # si la suma es mayor a la diagonal absoluta, la matriz no es diagonal dominante
        if(suma >= np.abs(A[i,i]) if estricto else suma > np.abs(A[i,i])):
            return False
    return True

"""## Comprobar Convergencia

Mediante el uso del radio espectral de una matriz, determina si un sistema de
ecuaciones lineales converge a una solución o no.
"""

def comprobarConvergenciaSolucion(A):
    valores, vectores = np.linalg.eig(A) # determina los valores propios de la matriz
    radioEspectral = np.max(np.abs(valores)) # determina el radio espectral de la matriz
    print('Radio espectral: ', radioEspectral, 'converge:', radioEspectral <= 1)
    return radioEspectral < 1


def resolverJacobi(A, b, iteraciones):
    '''
    Resuelve la matriz A de orden n x n mediante el método de Jacobi.

    Args:
        A (np.array): matriz de orden n x n
        b (np.array): vector de orden n
        iteraciones (int): número de iteraciones

    Returns:
        np.array: solución de la matriz A
    '''
    m, n = A.shape

    if(m!=n):
        print('La matriz no es cuadrada')
        return

    # esEstrictamenteDiagonalDominante = comprobarMatrizDiagonalDominante(A, estricto=True)
    # print(' es edd', esEstrictamenteDiagonalDominante)
    # if(esEstrictamenteDiagonalDominante == False):
    #     print('La matriz no es estrictamente diagonal dominante')
    #     return

    # construcción de parametros para aplicar el metodo de Jacobi
    D = np.diagflat([A.diagonal()])
    Au = (np.triu(A) - D) * -1
    Al = (np.tril(A) - D ) * -1

    # if(comprobarConvergenciaSolucion(np.matmul(np.linalg.inv(D), (Al + Au))) == False):
    #     print('La matriz no converge a una solución')
    #     return

    x = np.ones(n)

    # iteración del método de Jacobi
    for n in range(0, iteraciones):
        # encontrar x_k+1 mediante la ecuación de Jacobi
        x = np.matmul(np.linalg.inv(D), np.matmul(Al + Au, x)) + np.matmul(np.linalg.inv(D), b)

    return x

def resolverGaussSeidel(A, b, iteraciones):
    '''
    Resuelve un sistema de ecuaciones lineales mediante el método de Gauss-Seidel.

    Args:
        A (np.array): Matriz de la ecuación a resolver.
        b (np.array): Vector de los constantes de la ecuación.
        iteraciones (int): Número de iteraciones del método.

    Returns:
        np.array: Vector de solución de la ecuación.
    '''

    m, n = A.shape

    if(m!=n):
        print('La matriz no es cuadrada')
        return

    # if(comprobarMatrizDiagonalDominante(A, estricto=True) == False):
    #     print('La matriz no es estrictamente diagonal dominante')
    #     return

    D = np.diagflat([A.diagonal()])
    Au = (np.triu(A) - D) * -1
    Al = (np.tril(A) - D ) * -1

    if(comprobarConvergenciaSolucion(np.matmul(np.linalg.inv(D - Al), Au)) == False):
        print('La matriz no converge a una solución')
        return

    x = np.ones(n)


    for n in range(0, iteraciones):
        # encontrar solución x_k+1 usando la ecuación de Gauss-Seidel
        x = np.matmul(np.linalg.inv(D - Al), np.matmul(Au, x)) + np.matmul(np.linalg.inv(D - Al), b)

    return x


def resolverSOR(A, b, iteraciones, w):
    '''
    Resuelve el sistema de ecuaciones AX = B usando el método de SOR.

    Args:
        A (array): matriz de la ecuación AX = B
        b (array): vector de la ecuación AX = B
        iteraciones (int): número de iteraciones
        w (float): peso de la matriz diagonal dominante

    Returns:
        array: vector de la solución de la ecuación AX = B
    '''
    m, n = A.shape

    if(m!=n):
        print('La matriz no es cuadrada')
        return

    # if(comprobarMatrizDiagonalDominante(A, estricto=True) == False):
    #     print('La matriz no es estrictamente diagonal dominante')
    #     return

    # construir los parametros para aplicar el algoritmo de SOR
    D = np.diagflat([A.diagonal()])
    Au = (np.triu(A) - D) * -1
    Al = (np.tril(A) - D ) * -1

    # if(comprobarConvergenciaSolucion(np.matmul(np.linalg.inv(D - w*Al), w*Au + (1-w)*D)) == False):
    #     print('La matriz no converge a una solución')
    #     return

    x = np.ones(n)

    for n in range(0, iteraciones):
        # calcular la solución x_k+1 de la ecuación AX = B usando el algoritmo de SOR
        x = np.matmul(np.linalg.inv(D - w*Al), np.matmul(w*Au + (1-w)*D, x)) + np.matmul(np.linalg.inv(D - w*Al), w*b)

    return x
